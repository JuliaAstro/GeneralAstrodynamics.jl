# Attitude Dynamics

_Quaternion kinematics, and dynamics!_

```{julia}
#| output: false
#| echo: false
using AstrodynamicalModels
using ModelingToolkit
using ModelingToolkit: get_u0, get_p
```

## Overview

The Attitude model assumes a spacecraft with some orientation described by a
**scalar-last** quaternion, and body rates which are small enough such that they
appear constant for small numerical integration tolerance values.

:::{.callout-caution appearance="simple"}
You should normalize the quaternion vector at each time step using a
`ManifoldCallback` or `DiscreteCallback` when simulating this model!
Without normalizing, the solution will drift such that the quaternion
state vector is no longer a unit quaternion. The dynamics in this
model *assume* a unit quaternion norm!
:::

$$
\begin{aligned}
    \dot{q} &= \frac{1}{2} \begin{bmatrix}
        0 && \omega_3 && -\omega_2 && \omega_1 \\
        -\omega_3 && 0 && \omega_1 && \omega_2 \\
        \omega_2 && -\omega_1 && 0 && \omega_3 \\
        -\omega_1 && -\omega_2 && -\omega_3 && 0
    \end{bmatrix} q \\
    \dot{\omega} &= -J^{-1} (\omega\times) J \omega + J^{-1} L + u \\
\end{aligned}
$$

## Examples

```{julia}
#| echo: true
#| output: true
model = AttitudeSystem()
```

Let's compute the Jacobian for these dynamics.

```{julia}
#| echo: true
#| output: true
J = calculate_jacobian(AttitudeSystem())
```

Finally, let's construct a Julia function which implements these dynamics!

```{julia}
#| echo: true
#| output: true
f = AttitudeFunction()
let u = randn(7), p = [randn(9), randn(3), rand(3)], t = 0
    sys = f.sys
    u0 = get_u0(sys, ModelingToolkit.unknowns(sys) .=> u)
    p = get_p(sys, [:J => p[1], :L => p[2], :f => p[3]]) # Or get_p(sys, ModelingToolkit.parameters(sys) .=> p)
    f(u0, p, t)
end
```
