[{"id":3,"pagetitle":"Getting Started","title":"GeneralAstrodynamics.jl","ref":"/docs/dev/#GeneralAstrodynamics.jl","content":" GeneralAstrodynamics.jl Common astrodynamics calculations in Julia, with units! Note This package is fairly new, and documentation is even newer!  Thanks for your patience as we get these docs up and running.  For now, all we can offer are some humble docstrings. If you check back in September, you'll probably find some more detailed documentation, and examples!"},{"id":6,"pagetitle":"Docstrings","title":"Docstrings","ref":"/docs/dev/docstrings/#Docstrings","content":" Docstrings Documentation for all types, and functions in  GeneralAstrodynamics ."},{"id":7,"pagetitle":"Docstrings","title":"GeneralAstrodynamics","ref":"/docs/dev/docstrings/#GeneralAstrodynamics","content":" GeneralAstrodynamics"},{"id":8,"pagetitle":"Docstrings","title":"GeneralAstrodynamics.load_generic_spice_kernels!","ref":"/docs/dev/docstrings/#GeneralAstrodynamics.load_generic_spice_kernels!-Tuple{}","content":" GeneralAstrodynamics.load_generic_spice_kernels!  —  Method load_generic_spice_kernels!()\n Load several small SPICE kernels to support simple operations. The kernels loaded into memory sum to less than 11MB. Extended Help Calls  SPICE.furnsh  on the following kernels. de432s.bsp  (approximately 10MB) latest_leapseconds_lsk.tls  (approximately 5KB) gm_de440.tpc  (approximately 12KB) pck00011.tpc  (approximately 130KB) load_generic_spice_kernels!() defined at  /home/runner/work/GeneralAstrodynamics.jl/GeneralAstrodynamics.jl/src/GeneralAstrodynamics.jl:46 . source"},{"id":11,"pagetitle":"Getting Started","title":"AstrodynamicalCalculations.jl","ref":"/docs/lib/AstrodynamicalCalculations/stable/#AstrodynamicalCalculations.jl","content":" AstrodynamicalCalculations.jl Common calculations within orbital mechanics and astrodynamics."},{"id":12,"pagetitle":"Getting Started","title":"AstrodynamicalCalculations","ref":"/docs/lib/AstrodynamicalCalculations/stable/#AstrodynamicalCalculations","content":" AstrodynamicalCalculations  —  Module Common calculations within orbital mechanics and astrodynamics. Extended Help Imports AstrodynamicalCalculations.CR3BPCalculations AstrodynamicalCalculations.R2BPCalculations Base Core DocStringExtensions Reexport Exports CR3BPCalculations R2BPCalculations apoapsis_radius c3 cartesian_to_keplerian cartesian_to_perifocal conic converge converge! convergent_direction distance_scaling distance_to_primary distance_to_secondary diverge diverge! divergent_direction eccentricity eccentricity_vector hohmann jacobi_constant kepler keplerian_to_cartesian keplerian_to_perifocal lagrange_point lambert mean_motion nondimensional nondimensional_radii orbital_period orbital_radius orbital_speed periapsis_radius perifocal_to_cartesian perturb perturb! perturbation potential_energy primary_synodic_position redimensioned reduced_mass richardson_halo richardson_ic secondary_synodic_position semi_parameter semimajor_axis specific_angular_momentum specific_angular_momentum_vector specific_energy specific_potential_energy sphere_of_activity sphere_of_influence time_scaling time_since_periapsis true_anomaly v_infinity velocity_scaling zero_velocity_curves source"},{"id":13,"pagetitle":"Getting Started","title":"Installation","ref":"/docs/lib/AstrodynamicalCalculations/stable/#Installation","content":" Installation pkg> add AstrodynamicalCalculations"},{"id":14,"pagetitle":"Getting Started","title":"Getting Started","ref":"/docs/lib/AstrodynamicalCalculations/stable/#Getting-Started","content":" Getting Started One common task within first-year orbital mechanics courses is converting to, and from, Keplerian parameters (orbital elements). Kepler's prediction algorithm is another staple! These simple calculations are provided by the  R2BPCalculations  submodule within   AstrodynamicalCalculations . Tip The size of all of the vectors in these calculations are known at compile time.  You can  drastically  improve performance by using  StaticArrays  types, i.e.  SVector . julia> using AstrodynamicalCalculations\n\njulia> r = [0.0, 11681.0, 0.0];     # km\n\njulia> v = [5.134, 4.226, 2.787];   # km/s\n\njulia> μ = 398600.4354360959;       # km³ s⁻²\n\njulia> e, a, i, Ω, ω, ν = cartesian_to_keplerian(r, v, μ) \n(0.723452708202361, 24509.265399338536, 2.6442542356744734, 1.5707963267948966, 4.712449617676915, 1.5707356895026707)\n\njulia> T = orbital_period(a, μ) \n38186.19850882009\n\njulia> rₙ, vₙ = kepler(r, v, μ, 2.5T)\n([36872.96963754877, -2574.241491333036, 20016.549742861007], [-0.3141726028666592, -1.6044679459972122, -0.17054909314167882])"},{"id":17,"pagetitle":"CR3BP Equations","title":"Circular Restricted Three Body Equations","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#Circular-Restricted-Three-Body-Equations","content":" Circular Restricted Three Body Equations All three-body equations!"},{"id":18,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations","content":" AstrodynamicalCalculations.CR3BPCalculations  —  Module Common calculations within Circular Restricted Three Body Problem dynamics. Extended Help Imports Base Core DocStringExtensions LinearAlgebra Roots StaticArrays Exports converge converge! convergent_direction distance_scaling distance_to_primary distance_to_secondary diverge diverge! divergent_direction jacobi_constant lagrange_point nondimensional nondimensional_radii perturb perturb! perturbation potential_energy primary_synodic_position redimensioned reduced_mass richardson_halo richardson_ic secondary_synodic_position time_scaling velocity_scaling zero_velocity_curves source"},{"id":19,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.converge!","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.converge!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractMatrix{T} where T, AbstractMatrix{T} where T}","content":" AstrodynamicalCalculations.CR3BPCalculations.converge!  —  Method converge!(p, u, stm, Φ; eps)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Perturb halo orbit conditions in-place onto the orbit's stable manifold. source"},{"id":20,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.converge","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.converge-Tuple{AbstractVector{T} where T, AbstractMatrix{T} where T, AbstractMatrix{T} where T}","content":" AstrodynamicalCalculations.CR3BPCalculations.converge  —  Method converge(u, stm, Φ; eps)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Perturb halo orbit conditions onto the orbit's unstable manifold. source"},{"id":21,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.convergent_direction","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.convergent_direction-Tuple{AbstractMatrix{T} where T}","content":" AstrodynamicalCalculations.CR3BPCalculations.convergent_direction  —  Method convergent_direction(stm; atol)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Calculates the eigenvector associated with the stable manifold of a Monodromy matrix. source"},{"id":22,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.distance_scaling","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.distance_scaling-Tuple{Any}","content":" AstrodynamicalCalculations.CR3BPCalculations.distance_scaling  —  Method distance_scaling(a)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. The length scale factor used to nondimensionalize CR3BP states. source"},{"id":23,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.distance_to_primary","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.distance_to_primary-Tuple{Any, Any}","content":" AstrodynamicalCalculations.CR3BPCalculations.distance_to_primary  —  Method distance_to_primary(r, μ)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Returns synodic distance to primary body. source"},{"id":24,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.distance_to_secondary","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.distance_to_secondary-Tuple{Any, Any}","content":" AstrodynamicalCalculations.CR3BPCalculations.distance_to_secondary  —  Method distance_to_secondary(r, μ)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Returns synodic distance to secondary body. source"},{"id":25,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.diverge!","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.diverge!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractMatrix{T} where T, AbstractMatrix{T} where T}","content":" AstrodynamicalCalculations.CR3BPCalculations.diverge!  —  Method diverge!(p, u, stm, Φ; eps)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Perturb halo orbit conditions in-place onto the orbit's unstable manifold. source"},{"id":26,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.diverge","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.diverge-Tuple{AbstractVector{T} where T, AbstractMatrix{T} where T, AbstractMatrix{T} where T}","content":" AstrodynamicalCalculations.CR3BPCalculations.diverge  —  Method diverge(u, stm, Φ; eps)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Perturb halo orbit conditions onto the orbit's unstable manifold. source"},{"id":27,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.divergent_direction","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.divergent_direction-Tuple{AbstractMatrix{T} where T}","content":" AstrodynamicalCalculations.CR3BPCalculations.divergent_direction  —  Method divergent_direction(stm; atol)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Calculates the direction associated with the unstable manifold of a Monodromy matrix. source"},{"id":28,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.inertial_to_synodic","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.inertial_to_synodic-Tuple{AbstractVector{T} where T, Any, Any}","content":" AstrodynamicalCalculations.CR3BPCalculations.inertial_to_synodic  —  Method inertial_to_synodic(rᵢ, t, ω)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Given a barycentric-inertial Cartesian state, returns the state in the synodic (rotating) reference frame. source"},{"id":29,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.jacobi_constant","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.jacobi_constant-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.CR3BPCalculations.jacobi_constant  —  Method jacobi_constant(r, v, μ)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Returns the Jacobi Constant,  C  in the Synodic frame with Normalized units. source"},{"id":30,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.lagrange_point","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.lagrange_point-Tuple{Real, Int64}","content":" AstrodynamicalCalculations.CR3BPCalculations.lagrange_point  —  Method lagrange_point(μ, L)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Returns the lagrange points for a CR3BP system. Arguments: μ : Non-dimensional mass parameter for the CR3BP system. L : Langrange points requested, must be in range [1,5] Outputs: Tuple of Lagrange points Throws  ArgumentError  if L is out of range [1,5] References: Rund, 2018 source"},{"id":31,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.nondimensional","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.nondimensional-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, Any, Any, Any, Any}","content":" AstrodynamicalCalculations.CR3BPCalculations.nondimensional  —  Method nondimensional(r, v, t, a, μ₁, μ₂)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Normalizes a CR3BP orbit in the rotating reference frame. source"},{"id":32,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.nondimensional_radii","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.nondimensional_radii-Tuple{AbstractVector{T} where T, Any}","content":" AstrodynamicalCalculations.CR3BPCalculations.nondimensional_radii  —  Method nondimensional_radii(r, xᵢ)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Returns the spacecraft's nondimensional position w.r.t. body 1 (or 2). source"},{"id":33,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.perturb!","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.perturb!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractMatrix{T} where T, AbstractVector{T} where T}","content":" AstrodynamicalCalculations.CR3BPCalculations.perturb!  —  Method perturb!(p, u, stm, direction; eps)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Perturb a Cartesian state in-place along a halo orbit onto a stable or unstable manifold. source"},{"id":34,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.perturb","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.perturb-Tuple{AbstractVector{T} where T, AbstractMatrix{T} where T, AbstractVector{T} where T}","content":" AstrodynamicalCalculations.CR3BPCalculations.perturb  —  Method perturb(u, stm, direction; eps)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Perturb a Cartesian state along a halo orbit onto a stable or unstable manifold. source"},{"id":35,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.perturbation","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.perturbation-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T}","content":" AstrodynamicalCalculations.CR3BPCalculations.perturbation  —  Method perturbation(stm, direction; eps)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Return the perturbation in Cartesian state space along a halo orbit onto the provided direction of the provided manifold. source"},{"id":36,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.potential_energy","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.potential_energy-Tuple{Any, Any}","content":" AstrodynamicalCalculations.CR3BPCalculations.potential_energy  —  Method potential_energy(r, μ)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Returns the potential energy  U  in the Synodic frame with Normalized units. source"},{"id":37,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.primary_synodic_position","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.primary_synodic_position-Tuple{Any}","content":" AstrodynamicalCalculations.CR3BPCalculations.primary_synodic_position  —  Method primary_synodic_position(μ)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Position of primary body. source"},{"id":38,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.redimensioned","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.redimensioned-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, Any, Any, Any, Any}","content":" AstrodynamicalCalculations.CR3BPCalculations.redimensioned  —  Method redimensioned(rₙ, vₙ, tₙ, μ, a, Tₛ)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Redimensionalizes a CR3BP orbit in the rotating reference frame. source"},{"id":39,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.reduced_mass","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.reduced_mass-Tuple{Any, Any}","content":" AstrodynamicalCalculations.CR3BPCalculations.reduced_mass  —  Method reduced_mass(μ₁, μ₂)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Return the reduced mass. source"},{"id":40,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.richardson_halo","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.richardson_halo-Tuple{Any, Int64}","content":" AstrodynamicalCalculations.CR3BPCalculations.richardson_halo  —  Method richardson_halo(μ, L; Z, hemisphere, ϕ, length)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Returns an analytical solution for a Halo orbit about  L . Extended Help Arguments μ : Non-dimensional mass parameter for the CR3BP system. L : Lagrange point to orbit (L1 or L2). Z : Desired non-dimensional Z-amplitude for Halo orbit. hemisphere : Specifies northern or southern Halo orbit. ϕ : Desired Halo orbit phase. steps : Number of non-dimensional timepoints in returned state. Outputs Near-periodic initial condition  u Halo orbit period  T . Throws  ArgumentError  if L is not  1  or  2 . References: Rund, 2018 . source"},{"id":41,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.richardson_ic","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.richardson_ic-Tuple{Any, Int64}","content":" AstrodynamicalCalculations.CR3BPCalculations.richardson_ic  —  Method richardson_ic(μ, L; Z, hemisphere, ϕ)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Returns an analytical solution for a Halo orbit about  L . Extended Help Arguments μ : Non-dimensional mass parameter for the CR3BP system. L : Lagrange point to orbit (L1 or L2). Z : Desired non-dimensional Z-amplitude for Halo orbit. hemisphere : Specifies northern or southern Halo orbit. ϕ : Desired Halo orbit phase. steps : Number of non-dimensional timepoints in returned state. Outputs Near-periodic initial condition  u Halo orbit period  T . Throws  ArgumentError  if L is not  1  or  2 . References: Rund, 2018 . source"},{"id":42,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.secondary_synodic_position","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.secondary_synodic_position-Tuple{Any}","content":" AstrodynamicalCalculations.CR3BPCalculations.secondary_synodic_position  —  Method secondary_synodic_position(μ)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Position of primary body. source"},{"id":43,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.synodic_to_inertial","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.synodic_to_inertial-Tuple{AbstractVector{T} where T, Any, Any}","content":" AstrodynamicalCalculations.CR3BPCalculations.synodic_to_inertial  —  Method synodic_to_inertial(rₛ, t, ω)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Given the Synodic frame vector, returns the vector in the barycentric-inertial reference frame. source"},{"id":44,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.time_scaling","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.time_scaling-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.CR3BPCalculations.time_scaling  —  Method time_scaling(a, μ₁, μ₂)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. The time scale factor used to nondimensionalize CR3BP states. source"},{"id":45,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.velocity_scaling","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.velocity_scaling-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.CR3BPCalculations.velocity_scaling  —  Method velocity_scaling(a, μ₁, μ₂)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. The velocity scale factor used to nondimensionalize CR3BP states. source"},{"id":46,"pagetitle":"CR3BP Equations","title":"AstrodynamicalCalculations.CR3BPCalculations.zero_velocity_curves","ref":"/docs/lib/AstrodynamicalCalculations/stable/cr3bp/#AstrodynamicalCalculations.CR3BPCalculations.zero_velocity_curves-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, Real}","content":" AstrodynamicalCalculations.CR3BPCalculations.zero_velocity_curves  —  Method zero_velocity_curves(r, v, μ; nondimensional_range)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Returns a  Vector  of  Matrix  values. Each  Matrix  contains a 3-column nondimensional position trajectory in the Synodic frame which represents a Zero Velocity Curve. source"},{"id":49,"pagetitle":"R2BP Equations","title":"Restricted Two Body Equations","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#Restricted-Two-Body-Equations","content":" Restricted Two Body Equations All two-body equations!"},{"id":50,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations","content":" AstrodynamicalCalculations.R2BPCalculations  —  Module Common calculations within Restricted Two Body Problem dynamics. Extended Help Imports Base Core DocStringExtensions LinearAlgebra StaticArrays Exports apoapsis_radius c3 cartesian_to_keplerian cartesian_to_perifocal conic eccentricity eccentricity_vector hohmann kepler keplerian_to_cartesian keplerian_to_perifocal lambert mean_motion orbital_period orbital_radius orbital_speed periapsis_radius perifocal_to_cartesian semi_parameter semimajor_axis specific_angular_momentum specific_angular_momentum_vector specific_energy specific_potential_energy sphere_of_activity sphere_of_influence time_since_periapsis true_anomaly v_infinity source"},{"id":51,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.apoapsis_radius","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.apoapsis_radius-Tuple{Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.apoapsis_radius  —  Method apoapsis_radius(a, e)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns apoapsis distance, rₐ. source"},{"id":52,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.c3","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.c3-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.c3  —  Method c3(r, v, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns C3 value. source"},{"id":53,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.cartesian_to_keplerian","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.cartesian_to_keplerian-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.cartesian_to_keplerian  —  Method cartesian_to_keplerian(r, v, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns a Keplarian representation of a Cartesian orbital state. Algorithm taught in ENAE601. source"},{"id":54,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.cartesian_to_perifocal","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.cartesian_to_perifocal-NTuple{5, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.cartesian_to_perifocal  —  Method cartesian_to_perifocal(i, Ω, ω, r, v)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns the position and velocity vectors in the Perifocal frame. source"},{"id":55,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.conic","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.conic-Tuple{Any}","content":" AstrodynamicalCalculations.R2BPCalculations.conic  —  Method conic(e)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns the conic section, as specified by eccentricity  e . source"},{"id":56,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.eccentricity","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.eccentricity-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.eccentricity  —  Method eccentricity(r, v, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns orbital eccentricity, e. source"},{"id":57,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.eccentricity_vector","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.eccentricity_vector-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.eccentricity_vector  —  Method eccentricity_vector(r, v, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns orbital eccentricity vector e̅. source"},{"id":58,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.hohmann","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.hohmann-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.hohmann  —  Method hohmann(r₁, r₂, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Computes a Hohmann transfer, and returns the departure and  arrival velocity vectors.  source"},{"id":59,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.kepler","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.kepler-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.kepler  —  Method kepler(r, v, μ, Δt; atol, maxiter)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Solves Kepler's Problem, predicting the orbit's future state geometrically. source"},{"id":60,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.keplerian_speed","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.keplerian_speed-NTuple{5, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.keplerian_speed  —  Method keplerian_speed(p, e, ν, a, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns the instantaneous velocity,  v , for any orbital representation. source"},{"id":61,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.keplerian_to_cartesian","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.keplerian_to_cartesian-NTuple{7, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.keplerian_to_cartesian  —  Method keplerian_to_cartesian(e, a, i, Ω, ω, ν, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns a Cartesian representation of a Keplerian two-body orbital state in an inertial frame, centered at the center of mass of the central body. Algorithm taught in ENAE601. source"},{"id":62,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.keplerian_to_perifocal","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.keplerian_to_perifocal-NTuple{4, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.keplerian_to_perifocal  —  Method keplerian_to_perifocal(a, e, ν, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns position and velocity vectors in the Perifocal frame. source"},{"id":63,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.lambert","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.lambert-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.lambert  —  Method lambert(r̅₁, r̅₂, μ, Δt; trajectory, atol, maxiter)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Solves Lambert's problem through the use of univeral variables. source"},{"id":64,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.lambert_lancaster_blanchard","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.lambert_lancaster_blanchard-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, Number, Number}","content":" AstrodynamicalCalculations.R2BPCalculations.lambert_lancaster_blanchard  —  Method lambert_lancaster_blanchard(\n    r̲₁,\n    r̲₂,\n    μ,\n    Δt;\n    revolutions,\n    branch,\n    trajectory,\n    atol,\n    maxiter,\n    output_extrema\n)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. The following code was converted to Julia, from a  GitHub repository  that hosts a MATLAB implementation. At the time of writing, this respository has a BSD license. I'm providing the copyright notice here, as instructed by the license text. Copyright (c) 2018, Rody Oldenhuis\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation are those\nof the authors and should not be interpreted as representing official policies,\neither expressed or implied, of this project. source"},{"id":65,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.lambert_oldenhuis","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.lambert_oldenhuis-NTuple{5, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.lambert_oldenhuis  —  Method lambert_oldenhuis(r1vec, r2vec, tf, m, muC)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. The following code was converted to Julia, from a  GitHub repository  that hosts a MATLAB implementation. At the time of writing, this respository has a BSD license. I'm providing the copyright notice here, as instructed by the license text. Copyright (c) 2018, Rody Oldenhuis\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation are those\nof the authors and should not be interpreted as representing official policies,\neither expressed or implied, of this project. source"},{"id":66,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.lancaster_blanchard","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.lancaster_blanchard-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.lancaster_blanchard  —  Method lancaster_blanchard(x, q, m)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. The following code was converted to Julia, from a  GitHub repository  that hosts the MATLAB implementation. At the time of writing, the respository has a BSD license. I'm providing the copyright notice here, as instructed by the license text. Copyright (c) 2018, Rody Oldenhuis\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation are those\nof the authors and should not be interpreted as representing official policies,\neither expressed or implied, of this project. source"},{"id":67,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.mean_motion","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.mean_motion-Tuple{Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.mean_motion  —  Method mean_motion(a, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns mean motion, n. source"},{"id":68,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.minmax_distances","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.minmax_distances-NTuple{10, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.minmax_distances  —  Method minmax_distances(r̲₁, r̲₂, r₁, r₂, δₜ, a, v̲₁, v̲₂, m, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. The following code was converted to Julia, from a  GitHub repository  that hosts a MATLAB implementation. At the time of writing, this respository has a BSD license. I'm providing the copyright notice here, as instructed by the license text. Copyright (c) 2018, Rody Oldenhuis\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation are those\nof the authors and should not be interpreted as representing official policies,\neither expressed or implied, of this project. source"},{"id":69,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.orbital_period","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.orbital_period-Tuple{Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.orbital_period  —  Method orbital_period(a, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns the orbital period. source"},{"id":70,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.orbital_radius","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.orbital_radius-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.orbital_radius  —  Method orbital_radius(p, e, ν)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns distance, r. source"},{"id":71,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.orbital_speed","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.orbital_speed-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.orbital_speed  —  Method orbital_speed(r, a, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns instantaneous velocity, v, for any orbital representation. source"},{"id":72,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.periapsis_radius","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.periapsis_radius-Tuple{Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.periapsis_radius  —  Method periapsis_radius(a, e)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns periapsis distance, rₚ. source"},{"id":73,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.perifocal_to_cartesian","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.perifocal_to_cartesian-NTuple{5, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.perifocal_to_cartesian  —  Method perifocal_to_cartesian(i, Ω, ω, r, v)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns a spatial representation of the provied Perifocal state. source"},{"id":74,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.semi_parameter","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.semi_parameter-Tuple{Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.semi_parameter  —  Method semi_parameter(a, e)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns semilatus parameter, p. source"},{"id":75,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.semimajor_axis","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.semimajor_axis-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.semimajor_axis  —  Method semimajor_axis(r, v, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns semimajor axis parameter, a. source"},{"id":76,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.specific_angular_momentum","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.specific_angular_momentum-Tuple{Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.specific_angular_momentum  —  Method specific_angular_momentum(r, v)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns scalar specific angular momentum vector, h. source"},{"id":77,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.specific_angular_momentum_vector","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.specific_angular_momentum_vector-Tuple{Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.specific_angular_momentum_vector  —  Method specific_angular_momentum_vector(r, v)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns specific angular momentum vector, h̅. source"},{"id":78,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.specific_energy","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.specific_energy-Tuple{Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.specific_energy  —  Method specific_energy(a, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns specific orbital energy, ϵ. source"},{"id":79,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.specific_potential_energy","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.specific_potential_energy-Tuple{Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.specific_potential_energy  —  Method specific_potential_energy(r, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns potential energy for an orbit about a  RestrictedTwoBodySystem . source"},{"id":80,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.sphere_of_activity","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.sphere_of_activity-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.sphere_of_activity  —  Method sphere_of_activity(a, m, M)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Sphere of activity. source"},{"id":81,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.sphere_of_influence","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.sphere_of_influence-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.sphere_of_influence  —  Method sphere_of_influence(a, m, M)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Sphere of influence. source"},{"id":82,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.time_since_periapsis","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.time_since_periapsis-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.time_since_periapsis  —  Method time_since_periapsis(n, e, E)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns time since periapsis, t. source"},{"id":83,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.true_anomaly","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.true_anomaly-NTuple{4, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.true_anomaly  —  Method true_anomaly(r, h, e, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns true anomoly, ν. source"},{"id":84,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.v_infinity","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.v_infinity-Tuple{Any, Any, Any}","content":" AstrodynamicalCalculations.R2BPCalculations.v_infinity  —  Method v_infinity(r, v, μ)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. Returns v∞. source"},{"id":85,"pagetitle":"R2BP Equations","title":"AstrodynamicalCalculations.R2BPCalculations.σmax","ref":"/docs/lib/AstrodynamicalCalculations/stable/r2bp/#AstrodynamicalCalculations.R2BPCalculations.σmax-Tuple{Any}","content":" AstrodynamicalCalculations.R2BPCalculations.σmax  —  Method σmax(y)\n R2BP Dynamics This computation is valid for Restricted Two Body Problem (Keplerian) orbits. The following code was converted to Julia, from a  GitHub repository  that hosts a MATLAB implementation. At the time of writing, this respository has a BSD license. I'm providing the copyright notice here, as instructed by the license text. Copyright (c) 2018, Rody Oldenhuis\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation are those\nof the authors and should not be interpreted as representing official policies,\neither expressed or implied, of this project. source"},{"id":90,"pagetitle":"Getting Started","title":"AstrodynamicalModels.jl","ref":"/docs/lib/AstrodynamicalModels/stable/#AstrodynamicalModels.jl","content":" AstrodynamicalModels.jl Common models within astrodynamics!"},{"id":91,"pagetitle":"Getting Started","title":"Overview","ref":"/docs/lib/AstrodynamicalModels/stable/#Overview","content":" Overview This package extends  ModelingToolkit  to represent common astrodynamical models. All available models are shown on the  Docstrings  page. Consult the  Models  pages for more detail about each model in this package!"},{"id":92,"pagetitle":"Getting Started","title":"Usage","ref":"/docs/lib/AstrodynamicalModels/stable/#Usage","content":" Usage If you're familiar with  ModelingToolkit.jl , then you'll be able to use this package! Some  AstrodynamicalModels -specific usage instructions are provided here. Please don't be shy about making  Discourse  posts, or filing  issues  on GitHub!"},{"id":93,"pagetitle":"Getting Started","title":"Installation & Setup","ref":"/docs/lib/AstrodynamicalModels/stable/#Installation-and-Setup","content":" Installation & Setup This package can be installed just like any other  registered  Julia package. # To install wherever Julia code runs...\nimport Pkg\nPkg.add(\"AstrodynamicalModels\") # or ]add AstrodynamicalModels in Julia's REPL To load the package, simply enter  using AstrodynamicalModels . julia> using AstrodynamicalModels"},{"id":94,"pagetitle":"Getting Started","title":"Retrieving a Model","ref":"/docs/lib/AstrodynamicalModels/stable/#Retrieving-a-Model","content":" Retrieving a Model Each model within this package is implemented with a function – each function returns some  AbstractSystem  from  ModelingToolkit.jl . Typically, this will be an  ODESystem . If you're worried about overhead from calling each function every time you need a particular model, don't! Each function is implemented with  @memoize , so all results are cached the first time you call a model's function  with a particular function signature . julia> R2BPModel = R2BP() # Restricted Two-body Problem dynamics ERROR: UndefVarError: `R2BP` not defined julia> CR3BPModel = CR3BP() # Circular Restricted Three-body Problem dynamics ERROR: UndefVarError: `CR3BP` not defined julia> CR3BPModelWithSTM = CR3BP(; stm=true) # Optionally include state transition matrix dynamics ERROR: UndefVarError: `CR3BP` not defined"},{"id":95,"pagetitle":"Getting Started","title":"Using a Model","ref":"/docs/lib/AstrodynamicalModels/stable/#Using-a-Model","content":" Using a Model To actually  use  each model, you probably  also  want to load  ModelingToolkit  (and any other  SciML  packages of your choice). julia> using ModelingToolkit Now you can use any method defined for  ModelingToolkit.AbstractSystem  instances. Once again, the  ModelingToolkit  Documentation  are the best place to learn how to interact with  AbstractSystem  instances! Some quick examples are shown below."},{"id":96,"pagetitle":"Getting Started","title":"Check the Equations of Motion","ref":"/docs/lib/AstrodynamicalModels/stable/#Check-the-Equations-of-Motion","content":" Check the Equations of Motion julia> eqs = equations(R2BSystem()) 6-element Vector{Equation}:\n Differential(t)(x(t)) ~ ẋ(t)\n Differential(t)(y(t)) ~ ẏ(t)\n Differential(t)(z(t)) ~ ż(t)\n Differential(t)(ẋ(t)) ~ (-x(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3)\n Differential(t)(ẏ(t)) ~ (-y(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3)\n Differential(t)(ż(t)) ~ (-z(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3)"},{"id":97,"pagetitle":"Getting Started","title":"List the States and Parameters","ref":"/docs/lib/AstrodynamicalModels/stable/#List-the-States-and-Parameters","content":" List the States and Parameters julia> x = states(R2BSystem()) 6-element Vector{SymbolicUtils.BasicSymbolic{Real}}:\n x(t)\n y(t)\n z(t)\n ẋ(t)\n ẏ(t)\n ż(t) julia> p = parameters(R2BSystem()) 1-element Vector{SymbolicUtils.BasicSymbolic{Real}}:\n μ"},{"id":98,"pagetitle":"Getting Started","title":"Calculate the Jacobian","ref":"/docs/lib/AstrodynamicalModels/stable/#Calculate-the-Jacobian","content":" Calculate the Jacobian julia> J = calculate_jacobian(R2BSystem()) 6×6 Matrix{Num}:\n                                                                                                                                                                     0  …  1  0  0\n                                                                                                                                                                     0     0  1  0\n                                                                                                                                                                     0     0  0  1\n (-μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3) - 3x(t)*((-x(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))     0  0  0\n                                                        -3((-y(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*x(t)*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))     0  0  0\n                                                        -3x(t)*((-z(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))  …  0  0  0"},{"id":99,"pagetitle":"Getting Started","title":"Generate Code to Replicate the Model","ref":"/docs/lib/AstrodynamicalModels/stable/#Generate-Code-to-Replicate-the-Model","content":" Generate Code to Replicate the Model julia> print(build_function(R2BSystem())) function ()\n    #= /home/runner/.julia/packages/SymbolicUtils/ssQsQ/src/code.jl:373 =#\n    #= /home/runner/.julia/packages/SymbolicUtils/ssQsQ/src/code.jl:374 =#\n    #= /home/runner/.julia/packages/SymbolicUtils/ssQsQ/src/code.jl:375 =#\n    ODESystem(0x0000000000000006, Equation[Differential(t)(x(t)) ~ ẋ(t), Differential(t)(y(t)) ~ ẏ(t), Differential(t)(z(t)) ~ ż(t), Differential(t)(ẋ(t)) ~ (-x(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3), Differential(t)(ẏ(t)) ~ (-y(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3), Differential(t)(ż(t)) ~ (-z(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3)], t, SymbolicUtils.BasicSymbolic{Real}[x(t), y(t), z(t), ẋ(t), ẏ(t), ż(t)], SymbolicUtils.BasicSymbolic{Real}[μ], nothing, Dict{Any, Any}(:ż => ż(t), :μ => μ, :y => y(t), :ẏ => ẏ(t), :ẋ => ẋ(t), :z => z(t), :x => x(t)), Any[], Equation[], Base.RefValue{Vector{Num}}(Num[]), Base.RefValue{Any}((Num[0 0 0 1 0 0; 0 0 0 0 1 0; 0 0 0 0 0 1; (-μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3) - 3x(t)*((-x(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) -3y(t)*((-x(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) -3z(t)*((-x(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) 0 0 0; -3((-y(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*x(t)*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) (-μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3) - 3((-y(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*y(t)*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) -3((-y(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*z(t)*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) 0 0 0; -3x(t)*((-z(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) -3y(t)*((-z(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) (-μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3) - 3z(t)*((-z(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) 0 0 0], (false, false))), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), :R2B, ODESystem[], Dict{Any, Any}(), nothing, nothing, nothing, ModelingToolkit.SymbolicContinuousCallback[ModelingToolkit.SymbolicContinuousCallback(Equation[], Equation[])], ModelingToolkit.SymbolicDiscreteCallback[], nothing, nothing, nothing, nothing, false, nothing, nothing)\nend"},{"id":100,"pagetitle":"Getting Started","title":"Generate Code which Implements the Dynamics","ref":"/docs/lib/AstrodynamicalModels/stable/#Generate-Code-which-Implements-the-Dynamics","content":" Generate Code which Implements the Dynamics julia> print(R2BFunction()) ODEFunction{true, SciMLBase.FullSpecialize, ModelingToolkit.var\"#k#545\"{RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0x1a427848, 0x8fdb18c5, 0x2530bde3, 0x773b999f, 0xa3045880), Nothing}, RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0xcf59f416, 0xf641b45b, 0x2d699ab9, 0x3eb4e2fd, 0x0a0430fd), Nothing}}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, ModelingToolkit.var\"#___jac#551\"{RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0x9d8dcab8, 0x8047b9c3, 0x02954474, 0xd1737305, 0x78175e8f), Nothing}, RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0xfcaa3e02, 0x6b23567b, 0x425fdaf2, 0x263153d9, 0x1dbbe7f0), Nothing}}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Vector{Symbol}, Symbol, Vector{Symbol}, ModelingToolkit.var\"#630#generated_observed#555\"{Bool, ODESystem, Dict{Any, Any}, Vector{SymbolicUtils.BasicSymbolic{Real}}}, Nothing, ODESystem}(ModelingToolkit.var\"#k#545\"{RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0x1a427848, 0x8fdb18c5, 0x2530bde3, 0x773b999f, 0xa3045880), Nothing}, RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0xcf59f416, 0xf641b45b, 0x2d699ab9, 0x3eb4e2fd, 0x0a0430fd), Nothing}}(RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0x1a427848, 0x8fdb18c5, 0x2530bde3, 0x773b999f, 0xa3045880), Nothing}(nothing), RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0xcf59f416, 0xf641b45b, 0x2d699ab9, 0x3eb4e2fd, 0x0a0430fd), Nothing}(nothing)), LinearAlgebra.UniformScaling{Bool}(true), nothing, nothing, ModelingToolkit.var\"#___jac#551\"{RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0x9d8dcab8, 0x8047b9c3, 0x02954474, 0xd1737305, 0x78175e8f), Nothing}, RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0xfcaa3e02, 0x6b23567b, 0x425fdaf2, 0x263153d9, 0x1dbbe7f0), Nothing}}(RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0x9d8dcab8, 0x8047b9c3, 0x02954474, 0xd1737305, 0x78175e8f), Nothing}(nothing), RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0xfcaa3e02, 0x6b23567b, 0x425fdaf2, 0x263153d9, 0x1dbbe7f0), Nothing}(nothing)), nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, [Symbol(\"x(t)\"), Symbol(\"y(t)\"), Symbol(\"z(t)\"), Symbol(\"ẋ(t)\"), Symbol(\"ẏ(t)\"), Symbol(\"ż(t)\")], :t, [:μ], ModelingToolkit.var\"#630#generated_observed#555\"{Bool, ODESystem, Dict{Any, Any}, Vector{SymbolicUtils.BasicSymbolic{Real}}}(Core.Box(nothing), Core.Box(nothing), false, Core.Box(Equation[]), ODESystem(0x0000000000000006, Equation[Differential(t)(x(t)) ~ ẋ(t), Differential(t)(y(t)) ~ ẏ(t), Differential(t)(z(t)) ~ ż(t), Differential(t)(ẋ(t)) ~ (-x(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3), Differential(t)(ẏ(t)) ~ (-y(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3), Differential(t)(ż(t)) ~ (-z(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3)], t, SymbolicUtils.BasicSymbolic{Real}[x(t), y(t), z(t), ẋ(t), ẏ(t), ż(t)], SymbolicUtils.BasicSymbolic{Real}[μ], nothing, Dict{Any, Any}(:ż => ż(t), :μ => μ, :y => y(t), :ẏ => ẏ(t), :ẋ => ẋ(t), :z => z(t), :x => x(t)), Any[], Equation[], Base.RefValue{Vector{Num}}(Num[]), Base.RefValue{Any}((Num[0 0 0 1 0 0; 0 0 0 0 1 0; 0 0 0 0 0 1; (-μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3) - 3x(t)*((-x(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) -3y(t)*((-x(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) -3z(t)*((-x(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) 0 0 0; -3((-y(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*x(t)*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) (-μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3) - 3((-y(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*y(t)*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) -3((-y(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*z(t)*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) 0 0 0; -3x(t)*((-z(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) -3y(t)*((-z(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) (-μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3) - 3z(t)*((-z(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) 0 0 0], (false, false))), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), :R2B, ODESystem[], Dict{Any, Any}(), nothing, nothing, nothing, ModelingToolkit.SymbolicContinuousCallback[ModelingToolkit.SymbolicContinuousCallback(Equation[], Equation[])], ModelingToolkit.SymbolicDiscreteCallback[], nothing, nothing, nothing, nothing, false, nothing, nothing), Dict{Any, Any}(), SymbolicUtils.BasicSymbolic{Real}[μ]), nothing, ODESystem(0x0000000000000006, Equation[Differential(t)(x(t)) ~ ẋ(t), Differential(t)(y(t)) ~ ẏ(t), Differential(t)(z(t)) ~ ż(t), Differential(t)(ẋ(t)) ~ (-x(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3), Differential(t)(ẏ(t)) ~ (-y(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3), Differential(t)(ż(t)) ~ (-z(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3)], t, SymbolicUtils.BasicSymbolic{Real}[x(t), y(t), z(t), ẋ(t), ẏ(t), ż(t)], SymbolicUtils.BasicSymbolic{Real}[μ], nothing, Dict{Any, Any}(:ż => ż(t), :μ => μ, :y => y(t), :ẏ => ẏ(t), :ẋ => ẋ(t), :z => z(t), :x => x(t)), Any[], Equation[], Base.RefValue{Vector{Num}}(Num[]), Base.RefValue{Any}((Num[0 0 0 1 0 0; 0 0 0 0 1 0; 0 0 0 0 0 1; (-μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3) - 3x(t)*((-x(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) -3y(t)*((-x(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) -3z(t)*((-x(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) 0 0 0; -3((-y(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*x(t)*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) (-μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3) - 3((-y(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*y(t)*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) -3((-y(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*z(t)*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) 0 0 0; -3x(t)*((-z(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) -3y(t)*((-z(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) (-μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3) - 3z(t)*((-z(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t))) 0 0 0], (false, false))), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), :R2B, ODESystem[], Dict{Any, Any}(), nothing, nothing, nothing, ModelingToolkit.SymbolicContinuousCallback[ModelingToolkit.SymbolicContinuousCallback(Equation[], Equation[])], ModelingToolkit.SymbolicDiscreteCallback[], nothing, nothing, nothing, nothing, false, nothing, nothing))"},{"id":101,"pagetitle":"Getting Started","title":"Generate C/C++ and MATLAB Code","ref":"/docs/lib/AstrodynamicalModels/stable/#Generate-C/C-and-MATLAB-Code","content":" Generate C/C++ and MATLAB Code julia> print(build_function([eq.rhs for eq in equations(R2BSystem())], states(R2BSystem()), parameters(R2BSystem()); target=Symbolics.CTarget())) #include <math.h>\nvoid diffeqf(double* du, const double* RHS1, const double* RHS2) {\n  du[0] = RHS1[3];\n  du[1] = RHS1[4];\n  du[2] = RHS1[5];\n  du[3] = (-1 * RHS1[0] * RHS2[0]) / pow(sqrt(abs2(RHS1[1]) + abs2(RHS1[0]) + abs2(RHS1[2])), 3);\n  du[4] = (-1 * RHS1[1] * RHS2[0]) / pow(sqrt(abs2(RHS1[1]) + abs2(RHS1[0]) + abs2(RHS1[2])), 3);\n  du[5] = (-1 * RHS1[2] * RHS2[0]) / pow(sqrt(abs2(RHS1[1]) + abs2(RHS1[0]) + abs2(RHS1[2])), 3);\n} julia> print(build_function([eq.rhs for eq in equations(R2BSystem())], states(R2BSystem()), parameters(R2BSystem()); target=Symbolics.MATLABTarget())) diffeqf = @(internal_var___t,internal_var___u) [\n  internal_var___u(4);\n  internal_var___u(5);\n  internal_var___u(6);\n  (-1 * internal_var___u(1) * internal_var___p(1)) / sqrt(abs2(internal_var___u(2)) + abs2(internal_var___u(1)) + abs2(internal_var___u(3))) ^ 3;\n  (-1 * internal_var___u(2) * internal_var___p(1)) / sqrt(abs2(internal_var___u(2)) + abs2(internal_var___u(1)) + abs2(internal_var___u(3))) ^ 3;\n  (-1 * internal_var___u(3) * internal_var___p(1)) / sqrt(abs2(internal_var___u(2)) + abs2(internal_var___u(1)) + abs2(internal_var___u(3))) ^ 3;\n]; If you're interested in learning a bit about each astrodynamical model, or you'd like more specific examples which show how to use each model, consult the  Models  pages!"},{"id":104,"pagetitle":"Attitude","title":"Attitude Dynamics","ref":"/docs/lib/AstrodynamicalModels/stable/Attitude/#Attitude-Dynamics","content":" Attitude Dynamics Quaternion kinematics, and dynamics!"},{"id":105,"pagetitle":"Attitude","title":"Overview","ref":"/docs/lib/AstrodynamicalModels/stable/Attitude/#Overview","content":" Overview The Attitude model assumes a spacecraft with some orientation described by a  scalar-last  quaternion, and body rates which are small enough such that they appear constant for small numerical integration tolerance values. Danger You should normalize the quaternion vector at each time step using a  ManifoldCallback  or  DiscreteCallback  when simulating this model! Without normalizing, the solution will drift such that the quaternion state vector is no longer a unit quaternion. The dynamics in this  model  assume  a unit quaternion norm! \\[\\begin{aligned}\n    \\dot{q} &= \\frac{1}{2} \\begin{bmatrix}\n        0 && \\omega_3 && -\\omega_2 && \\omega_1 \\\\\n        -\\omega_3 && 0 && \\omega_1 && \\omega_2 \\\\\n        \\omega_2 && -\\omega_1 && 0 && \\omega_3 \\\\\n        -\\omega_1 && -\\omega_2 && -\\omega_3 && 0\n    \\end{bmatrix} q \\\\\n    \\dot{\\omega} &= -J^{-1} (\\omega\\times) J \\omega + J^{-1} L + u \\\\\n\\end{aligned}\\]"},{"id":106,"pagetitle":"Attitude","title":"Examples","ref":"/docs/lib/AstrodynamicalModels/stable/Attitude/#Examples","content":" Examples julia> model = AttitudeSystem() Model Attitude with 7 equations \n States (7): \n  (q(t))[1]: scalar-last attitude quaternion\n  (q(t))[2]: scalar-last attitude quaternion\n  (q(t))[3]: scalar-last attitude quaternion\n  (q(t))[4]: scalar-last attitude quaternion\n⋮\n Parameters (15): \n  J[1, 1]: moment of inertial matrix\n  J[2, 1]: moment of inertial matrix\n  J[3, 1]: moment of inertial matrix\n  J[1, 2]: moment of inertial matrix\n⋮ Let's compute the Jacobian for these dynamics. julia> J = calculate_jacobian(AttitudeSystem()) 7×7 Matrix{Num}:\n                 0  …                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (1//2)*(q(t))[2]\n (-1//2)*(ω(t))[3]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (-1//2)*(q(t))[1]\n  (1//2)*(ω(t))[2]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           (1//2)*(q(t))[4]\n (-1//2)*(ω(t))[1]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (-1//2)*(q(t))[3]\n                 0      ((J[1, 2]*J[2, 3] - J[1, 3]*J[2, 2])*(J[1, 3]*(ω(t))[2] - J[2, 3]*(ω(t))[1])) / (J[1, 1]*(J[2, 2]*J[3, 3] - J[2, 3]*J[3, 2]) - J[1, 2]*(J[2, 1]*J[3, 3] - J[2, 3]*J[3, 1]) + J[1, 3]*(J[2, 1]*J[3, 2] - J[2, 2]*J[3, 1])) + ((-J[1, 1]*(ω(t))[1] - J[1, 2]*(ω(t))[2] - 2J[1, 3]*(ω(t))[3] + J[3, 3]*(ω(t))[1])*(-J[1, 2]*J[3, 3] + J[1, 3]*J[3, 2])) / (J[1, 1]*(J[2, 2]*J[3, 3] - J[2, 3]*J[3, 2]) - J[1, 2]*(J[2, 1]*J[3, 3] - J[2, 3]*J[3, 1]) + J[1, 3]*(J[2, 1]*J[3, 2] - J[2, 2]*J[3, 1])) + ((J[2, 1]*(ω(t))[1] + J[2, 2]*(ω(t))[2] + 2J[2, 3]*(ω(t))[3] - J[3, 3]*(ω(t))[2])*(J[2, 2]*J[3, 3] - J[2, 3]*J[3, 2])) / (J[1, 1]*(J[2, 2]*J[3, 3] - J[2, 3]*J[3, 2]) - J[1, 2]*(J[2, 1]*J[3, 3] - J[2, 3]*J[3, 1]) + J[1, 3]*(J[2, 1]*J[3, 2] - J[2, 2]*J[3, 1]))\n                 0  …  ((-J[1, 1]*J[2, 3] + J[1, 3]*J[2, 1])*(J[1, 3]*(ω(t))[2] - J[2, 3]*(ω(t))[1])) / (J[1, 1]*(J[2, 2]*J[3, 3] - J[2, 3]*J[3, 2]) - J[1, 2]*(J[2, 1]*J[3, 3] - J[2, 3]*J[3, 1]) + J[1, 3]*(J[2, 1]*J[3, 2] - J[2, 2]*J[3, 1])) + ((-J[2, 1]*J[3, 3] + J[2, 3]*J[3, 1])*(J[2, 1]*(ω(t))[1] + J[2, 2]*(ω(t))[2] + 2J[2, 3]*(ω(t))[3] - J[3, 3]*(ω(t))[2])) / (J[1, 1]*(J[2, 2]*J[3, 3] - J[2, 3]*J[3, 2]) - J[1, 2]*(J[2, 1]*J[3, 3] - J[2, 3]*J[3, 1]) + J[1, 3]*(J[2, 1]*J[3, 2] - J[2, 2]*J[3, 1])) + ((J[1, 1]*J[3, 3] - J[1, 3]*J[3, 1])*(-J[1, 1]*(ω(t))[1] - J[1, 2]*(ω(t))[2] - 2J[1, 3]*(ω(t))[3] + J[3, 3]*(ω(t))[1])) / (J[1, 1]*(J[2, 2]*J[3, 3] - J[2, 3]*J[3, 2]) - J[1, 2]*(J[2, 1]*J[3, 3] - J[2, 3]*J[3, 1]) + J[1, 3]*(J[2, 1]*J[3, 2] - J[2, 2]*J[3, 1]))\n                 0      ((J[2, 1]*J[3, 2] - J[2, 2]*J[3, 1])*(J[2, 1]*(ω(t))[1] + J[2, 2]*(ω(t))[2] + 2J[2, 3]*(ω(t))[3] - J[3, 3]*(ω(t))[2])) / (J[1, 1]*(J[2, 2]*J[3, 3] - J[2, 3]*J[3, 2]) - J[1, 2]*(J[2, 1]*J[3, 3] - J[2, 3]*J[3, 1]) + J[1, 3]*(J[2, 1]*J[3, 2] - J[2, 2]*J[3, 1])) + ((J[1, 1]*J[2, 2] - J[1, 2]*J[2, 1])*(J[1, 3]*(ω(t))[2] - J[2, 3]*(ω(t))[1])) / (J[1, 1]*(J[2, 2]*J[3, 3] - J[2, 3]*J[3, 2]) - J[1, 2]*(J[2, 1]*J[3, 3] - J[2, 3]*J[3, 1]) + J[1, 3]*(J[2, 1]*J[3, 2] - J[2, 2]*J[3, 1])) + ((-J[1, 1]*J[3, 2] + J[1, 2]*J[3, 1])*(-J[1, 1]*(ω(t))[1] - J[1, 2]*(ω(t))[2] - 2J[1, 3]*(ω(t))[3] + J[3, 3]*(ω(t))[1])) / (J[1, 1]*(J[2, 2]*J[3, 3] - J[2, 3]*J[3, 2]) - J[1, 2]*(J[2, 1]*J[3, 3] - J[2, 3]*J[3, 1]) + J[1, 3]*(J[2, 1]*J[3, 2] - J[2, 2]*J[3, 1])) Finally, let's construct a Julia function which implements these dynamics! julia> f = AttitudeFunction() (::ODEFunction{true, SciMLBase.FullSpecialize, ModelingToolkit.var\"#k#545\"{RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0x5714a6b6, 0xb7dac537, 0xcb7f7241, 0xcf56a326, 0x847b40e2), Nothing}, RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0x0c55803e, 0xee8b3f56, 0x07add566, 0x31521ec7, 0xfa6dee30), Nothing}}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, ModelingToolkit.var\"#___jac#551\"{RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0xfb892936, 0xd7fb3a56, 0xf4197e11, 0x42d93c43, 0xe7bd4d40), Nothing}, RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0x699bccfc, 0xbde11283, 0xa48cd85c, 0x99f054f6, 0x2e2321c8), Nothing}}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Vector{Symbol}, Symbol, Vector{Symbol}, ModelingToolkit.var\"#630#generated_observed#555\"{Bool, ODESystem, Dict{Any, Any}, Vector{SymbolicUtils.BasicSymbolic{Real}}}, Nothing, ODESystem}) (generic function with 1 method) julia> let u = randn(7), p = randn(15), t = 0\n           f(u, p, t)\n       end 7-element Vector{Float64}:\n -0.13788050944032137\n -0.37297856000959434\n  0.03657593143266216\n -0.26946034195078444\n  0.2972775800545082\n -2.236931664906569\n -0.2668641323407184"},{"id":109,"pagetitle":"CR3BP","title":"Circular Restricted Three-body Dynamics","ref":"/docs/lib/AstrodynamicalModels/stable/CR3BP/#Circular-Restricted-Three-body-Dynamics","content":" Circular Restricted Three-body Dynamics Also known as CR3BP dynamics!"},{"id":110,"pagetitle":"CR3BP","title":"Overview","ref":"/docs/lib/AstrodynamicalModels/stable/CR3BP/#Overview","content":" Overview The Circular Restricted Three-body Problem (CR3BP) assumes a massless spacecraft which moves due to the gravity of  two  celestial bodies which orbit their common center of mass. This may seem like an arbitrary model, but it's actually a pretty decent approximation for how  a spacecraft moves nearby the Earth and the Sun, the Earth and the Moon, the Sun and  Jupiter, and other systems in our solar system! The equations of motion  are provided below. \\[\\begin{aligned}\n\\frac{dx(t)}{dt} =& ẋ\\left( t \\right) \\\\\n\\frac{dy(t)}{dt} =& ẏ\\left( t \\right) \\\\\n\\frac{dz(t)}{dt} =& ż\\left( t \\right) \\\\\n\\frac{dẋ(t)}{dt} =& 2 ẏ\\left( t \\right) - \\left( \\frac{1}{\\sqrt{\\left( \\mu + x\\left( t \\right) \\right)^{2} + \\left( y\\left( t \\right) \\right)^{2} + \\left( z\\left( t \\right) \\right)^{2}}} \\right)^{3} \\left( 1 - \\mu \\right) \\left( \\mu + x\\left( t \\right) \\right) - \\left( \\frac{1}{\\sqrt{\\left( -1 + \\mu + x\\left( t \\right) \\right)^{2} + \\left( y\\left( t \\right) \\right)^{2} + \\left( z\\left( t \\right) \\right)^{2}}} \\right)^{3} \\mu \\left( -1 + \\mu + x\\left( t \\right) \\right) + x\\left( t \\right) \\\\\n\\frac{dẏ(t)}{dt} =&  - 2 ẋ\\left( t \\right) - \\left( \\left( \\frac{1}{\\sqrt{\\left( \\mu + x\\left( t \\right) \\right)^{2} + \\left( y\\left( t \\right) \\right)^{2} + \\left( z\\left( t \\right) \\right)^{2}}} \\right)^{3} \\left( 1 - \\mu \\right) + \\left( \\frac{1}{\\sqrt{\\left( -1 + \\mu + x\\left( t \\right) \\right)^{2} + \\left( y\\left( t \\right) \\right)^{2} + \\left( z\\left( t \\right) \\right)^{2}}} \\right)^{3} \\mu \\right) y\\left( t \\right) + y\\left( t \\right) \\\\\n\\frac{dż(t)}{dt} =& \\left(  - \\left( \\frac{1}{\\sqrt{\\left( \\mu + x\\left( t \\right) \\right)^{2} + \\left( y\\left( t \\right) \\right)^{2} + \\left( z\\left( t \\right) \\right)^{2}}} \\right)^{3} \\left( 1 - \\mu \\right) - \\left( \\frac{1}{\\sqrt{\\left( -1 + \\mu + x\\left( t \\right) \\right)^{2} + \\left( y\\left( t \\right) \\right)^{2} + \\left( z\\left( t \\right) \\right)^{2}}} \\right)^{3} \\mu \\right) z\\left( t \\right)\n\\end{aligned}\\]"},{"id":111,"pagetitle":"CR3BP","title":"Examples","ref":"/docs/lib/AstrodynamicalModels/stable/CR3BP/#Examples","content":" Examples State transition dynamics are particularly valuable for CR3BP models. Recall that the state transition matrix is simply the local linearization of a spacecraft within CR3BP dynamics. Let's look at the Jacobian (another word for \"local linearization\") below, evaluated at some random state. julia> f = CR3BPFunction(; jac=true) ERROR: UndefVarError: `CR3BPFunction` not defined julia> let x = randn(6), p = rand((0.0, 0.5)), t = 0\n           f.jac(x, p, t)\n       end ERROR: UndefVarError: `f` not defined The Jacobian will always have this form (zeros in the top-left, the identity matrix in the top-right, a dense matrix in the  bottom-left, and the same sparse \"-2, 2\" matrix in the bottom-right). We can include the state transition dynamics in our model with   stm=true , initialize the state transition matrix states to the  identity matrix, and propagate our spacecraft for one periodic orbit: the result is known as the Monodromy Matrix! The Monodromy Matrix provides stability characteristics for the entire periodic orbit. julia> model = CR3BSystem(; stm=true) Model CR3BWithSTM with 42 equations \n States (42): \n  x(t)\n  y(t)\n  z(t)\n  ẋ(t)\n⋮\n Parameters (1): \n  μ Note that periodic orbits are not easy to find within CR3BP dynamics. Various algorithms have been developed to analytically approximate,  and numerically refine, periodic CR3BP orbits. Some of those  algorithms have already been implemented in Julia! See   OrbitalTrajectories  and  GeneralAstrodynamics ."},{"id":114,"pagetitle":"Entry","title":"Planar Entry Dynamics","ref":"/docs/lib/AstrodynamicalModels/stable/Entry/#Planar-Entry-Dynamics","content":" Planar Entry Dynamics Also known as canonical entry dynamics!"},{"id":115,"pagetitle":"Entry","title":"Overview","ref":"/docs/lib/AstrodynamicalModels/stable/Entry/#Overview","content":" Overview The Planar Entry model assumes a spacecraft moving in an exponential atmosphere about a spherical planet. Acceleration due to gravity is ignored. The equations of motion are shown below. \\[\\begin{aligned}\n  \\dot{\\gamma} &= \\frac{1}{v} \\left( L_m - (1 - \\frac{v^2}{v_c^2}) g \\cos{\\gamma} \\right) \\\\\n  \\dot{v} &= -D_m - g \\sin{\\gamma} \\\\\n  \\dot{r} &= v \\sin{\\gamma} \\\\\n  \\dot{\\theta} &= \\frac{v}{r} \\cos{\\gamma} \\\\\n\\end{aligned}\\]"},{"id":116,"pagetitle":"Entry","title":"Examples","ref":"/docs/lib/AstrodynamicalModels/stable/Entry/#Examples","content":" Examples julia> model = PlanarEntrySystem() Model PlanarEntry with 4 equations \n States (4): \n  γ(t): flight path angle in degrees\n  v(t): airspeed in meters per second\n  r(t): polar distance relative to planet center in meters\n  θ(t): polar angle relative to planet horizontal in degrees\n Parameters (7): \n  R: spherical planet radius\n  P: atmospheric density at sea level in kilograms per meter cubed\n  H: scale factor for exponential atmosphere in meters\n  m: entry vehicle mass in kilograms\n⋮ Let's compute the Jacobian for these dynamics. julia> J = calculate_jacobian(PlanarEntrySystem()) 4×4 Matrix{Num}:\n (sin(γ(t))*((R / r(t))^2)*(1 - ((v(t) / sqrt(μ / r(t)))^2))*μ) / ((R^2)*v(t))  …  0\n                                         (-((R / r(t))^2)*cos(γ(t))*μ) / (R^2)     0\n                                                                v(t)*cos(γ(t))     0\n                                                      (-sin(γ(t))*v(t)) / r(t)     0 Finally, let's construct a Julia function which implements these dynamics! julia> f = PlanarEntryFunction() (::ODEFunction{true, SciMLBase.FullSpecialize, ModelingToolkit.var\"#k#545\"{RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0x510be63b, 0x5375dd43, 0x02383486, 0x537f71a3, 0x878b2e96), Nothing}, RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0xba97c8c8, 0xbca3bd0a, 0xd551efee, 0x49ce5ec8, 0x7921545c), Nothing}}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, ModelingToolkit.var\"#___jac#551\"{RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0xb736dc56, 0x5f8c4599, 0xd86410d6, 0x8139d429, 0xb1d95b54), Nothing}, RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0xf9d68983, 0x99e2bc90, 0x11795c0a, 0x1d37149f, 0xedb90c33), Nothing}}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Vector{Symbol}, Symbol, Vector{Symbol}, ModelingToolkit.var\"#630#generated_observed#555\"{Bool, ODESystem, Dict{Any, Any}, Vector{SymbolicUtils.BasicSymbolic{Real}}}, Nothing, ODESystem}) (generic function with 1 method) julia> let u = abs.(randn(4)), p = abs.(randn(7)), t = 0\n           f(u, p, t)\n       end 4-element Vector{Float64}:\n  4.521159689425291\n -0.37666511412162096\n  0.9749285590613717\n  0.2785620346557619"},{"id":119,"pagetitle":"NBP","title":"N-body Problem Dynamics","ref":"/docs/lib/AstrodynamicalModels/stable/NBP/#N-body-Problem-Dynamics","content":" N-body Problem Dynamics Also known as NBP dynamics!"},{"id":120,"pagetitle":"NBP","title":"Overview","ref":"/docs/lib/AstrodynamicalModels/stable/NBP/#Overview","content":" Overview In an astrodynamical context, the N-body problem assumes  $N$  celestial bodies which move with respect to some common origin. A body  $i$  moves due to the cumulative gravity of every other body in the system. This problem is notoriously difficult because it cannot be solved analytically for  $N\\geq3$ !"},{"id":121,"pagetitle":"NBP","title":"Examples","ref":"/docs/lib/AstrodynamicalModels/stable/NBP/#Examples","content":" Examples All  NBSystem  calls require the number of bodies to be specified as the first argument, like so. As always, use the  stm  argument at your leisure. Beware, though! using  stm=true  for N-body systems with more than 5 bodies may cause  NBSystem  to compute for a  really, really  long time! True story –  v1.0.1  of this package had a version of these docs which tried to compute  NBSystem(30; stm=true) . That resulted in GitHub and JuliaHub failing the job on a timeout after  several hours  – at first I was surprised, until I realized that appending state transition matrix dynamics to a 30-body system results in a total of 32580 states! If you're curious, the number of states of an N-body system with state transition matrix dynamics appended is equivalent to  N*6 + (N*6)^2 . julia> model = NBSystem(2; stm=true) Model NBPWithSTM with 156 equations \n States (156): \n  (x(t))[1]\n  (y(t))[1]\n  (z(t))[1]\n  (x(t))[2]\n⋮\n Parameters (3): \n  G\n  m[1]\n  m[2] Like other models, we can compute the Jacobian for these dynamics. julia> using SparseArrays julia> J = sparse(calculate_jacobian(NBSystem(4))) 24×24 SparseArrays.SparseMatrixCSC{Num, Int64} with 156 stored entries:\n⎡⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⎤\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⎥\n⎢⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⎥\n⎢⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⎥\n⎣⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⎦ Finally, let's construct a Julia function which implements these dynamics! julia> f = NBFunction(2) (::ODEFunction{true, SciMLBase.FullSpecialize, ModelingToolkit.var\"#k#545\"{RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0xdecfc607, 0x619b8c8d, 0x8586c750, 0x7543d6c1, 0x9ab728e8), Nothing}, RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0xbfc600dc, 0xdfdaa0f9, 0xcfb4e7c4, 0x81fd24f0, 0x9622d3c3), Nothing}}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Vector{Symbol}, Symbol, Vector{Symbol}, ModelingToolkit.var\"#630#generated_observed#555\"{Bool, ODESystem, Dict{Any, Any}, Vector{SymbolicUtils.BasicSymbolic{Real}}}, Nothing, ODESystem}) (generic function with 1 method) julia> let u = randn(12), m = randn(2), G = rand(), t = 0\n           f(u, [G, m...], t)\n       end 12-element Vector{Float64}:\n -0.10615891745448879\n  0.1940922089701762\n  0.27405248230091495\n  2.1863666558188424\n -0.7478870825125142\n -0.12445061282144096\n -0.016331820208503597\n -0.007866826902971875\n  0.012300604554773867\n -0.017579660607756783\n -0.008467895510030682\n  0.01324043802726658"},{"id":124,"pagetitle":"R2BP","title":"Restricted Two-body Dynamics","ref":"/docs/lib/AstrodynamicalModels/stable/R2BP/#Restricted-Two-body-Dynamics","content":" Restricted Two-body Dynamics Also known as R2BP dynamics!"},{"id":125,"pagetitle":"R2BP","title":"Overview","ref":"/docs/lib/AstrodynamicalModels/stable/R2BP/#Overview","content":" Overview The Restricted Two-body Problem (R2BP) assumes a massless spacecraft which moves due to the gravity of  one  celestial body: one star, or one planet, or one moon, or one asteroid. The equations of motion for R2BP dynamics are shown below. \\[\\begin{aligned}\n\\frac{dx(t)}{dt} =& ẋ\\left( t \\right) \\\\\n\\frac{dy(t)}{dt} =& ẏ\\left( t \\right) \\\\\n\\frac{dz(t)}{dt} =& ż\\left( t \\right) \\\\\n\\frac{dẋ(t)}{dt} =& \\frac{ - \\mu x\\left( t \\right)}{\\left( \\sqrt{x^2\\left(t\\right) + y^2\\left(t\\right) + z^2\\left(t\\right)} \\right)^{3}} \\\\\n\\frac{dẏ(t)}{dt} =& \\frac{ - \\mu y\\left( t \\right)}{\\left( \\sqrt{x^2\\left(t\\right) + y^2\\left(t\\right) + z^2\\left(t\\right)} \\right)^{3}} \\\\\n\\frac{dż(t)}{dt} =& \\frac{ - \\mu z\\left( t \\right)}{\\left( \\sqrt{x^2\\left(t\\right) + y^2\\left(t\\right) + z^2\\left(t\\right)} \\right)^{3}}\n\\end{aligned}\\]"},{"id":126,"pagetitle":"R2BP","title":"Examples","ref":"/docs/lib/AstrodynamicalModels/stable/R2BP/#Examples","content":" Examples julia> model = R2BSystem() Model R2B with 6 equations \n States (6): \n  x(t)\n  y(t)\n  z(t)\n  ẋ(t)\n⋮\n Parameters (1): \n  μ Every model also offers  optional  state transition matrix dynamics. Use  stm=true  to append the state transition matrix dynamics to your model's equations of motion. State transition dynamics can also be thought of the model's  local linearization . Note The state transition dynamics for  R2BSystem  are not  nearly  as useful as the state transition dynamics within  CR3BP  models. Within CR3BP dynamics, a spacecraft's local linearization offers stability characteristics for periodic orbits, and provides stable and unstable directions (in state-space) for invariant manifolds about periodic orbits and Lagrange points. julia> model = R2BSystem(; stm=true) Model R2BWithSTM with 42 equations \n States (42): \n  x(t)\n  y(t)\n  z(t)\n  ẋ(t)\n⋮\n Parameters (1): \n  μ Let's compute the Jacobian for these dynamics. julia> J = calculate_jacobian(R2BSystem()) 6×6 Matrix{Num}:\n                                                                                                                                                                     0  …  1  0  0\n                                                                                                                                                                     0     0  1  0\n                                                                                                                                                                     0     0  0  1\n (-μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^3) - 3x(t)*((-x(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))     0  0  0\n                                                        -3((-y(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*x(t)*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))     0  0  0\n                                                        -3x(t)*((-z(t)*μ) / (sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))^6))*sqrt(abs2(y(t)) + abs2(x(t)) + abs2(z(t)))  …  0  0  0 Finally, let's construct a Julia function which implements these dynamics! julia> f = R2BFunction() (::ODEFunction{true, SciMLBase.FullSpecialize, ModelingToolkit.var\"#k#545\"{RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0x1a427848, 0x8fdb18c5, 0x2530bde3, 0x773b999f, 0xa3045880), Nothing}, RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0xcf59f416, 0xf641b45b, 0x2d699ab9, 0x3eb4e2fd, 0x0a0430fd), Nothing}}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, ModelingToolkit.var\"#___jac#551\"{RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0x9d8dcab8, 0x8047b9c3, 0x02954474, 0xd1737305, 0x78175e8f), Nothing}, RuntimeGeneratedFunctions.RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0xfcaa3e02, 0x6b23567b, 0x425fdaf2, 0x263153d9, 0x1dbbe7f0), Nothing}}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Vector{Symbol}, Symbol, Vector{Symbol}, ModelingToolkit.var\"#630#generated_observed#555\"{Bool, ODESystem, Dict{Any, Any}, Vector{SymbolicUtils.BasicSymbolic{Real}}}, Nothing, ODESystem}) (generic function with 1 method) julia> let u = randn(6), p = [3e6], t = 0\n           f(u, p, t)\n       end 6-element Vector{Float64}:\n      2.3332371473210896\n      0.7340832195656589\n      2.0512789365084863\n -70885.45498870542\n 762528.8618143481\n -71049.53378008286"},{"id":129,"pagetitle":"Docstrings","title":"Documentation","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#Documentation","content":" Documentation All docstrings!"},{"id":130,"pagetitle":"Docstrings","title":"AstrodynamicalModels.AstrodynamicalModels","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.AstrodynamicalModels","content":" AstrodynamicalModels.AstrodynamicalModels  —  Module Provides astrodynamical models as  AstrodynamicalModels.ODESystems . Check out the  ModelingToolkit  docs to learn how to use these systems for orbit propagation with  DifferentialEquations , or see  GeneralAstrodynamics  for some convenient orbit propagation wrappers. Extended help License MIT License Copyright (c) 2023 Joseph D Carpinelli Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Exports AttitudeFunction AttitudeParameters AttitudeState AttitudeSystem CR3BFunction CR3BOrbit CR3BParameters CR3BSystem CartesianState NBFunction NBSystem PlanarEntryFunction PlanarEntryParameters PlanarEntryState PlanarEntrySystem R2BFunction R2BOrbit R2BParameters R2BSystem Imports Base Core DocStringExtensions LinearAlgebra Memoize ModelingToolkit SciMLBase StaticArrays Symbolics source"},{"id":131,"pagetitle":"Docstrings","title":"AstrodynamicalModels.AstrodynamicalOrbit","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.AstrodynamicalOrbit","content":" AstrodynamicalModels.AstrodynamicalOrbit  —  Type abstract type AstrodynamicalOrbit{U, P} An abstract supertype for all orbits.  Extended Help To support the  AstrodynamicalOrbit  interface, you must implement the following methods. AstrodynamicalModels.states(orbit) AstrodynamicalModels.parameters(orbit) source"},{"id":132,"pagetitle":"Docstrings","title":"AstrodynamicalModels.AstrodynamicalParameters","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.AstrodynamicalParameters","content":" AstrodynamicalModels.AstrodynamicalParameters  —  Type abstract type AstrodynamicalParameters{F, N} <: StaticArraysCore.FieldVector{N, F} An abstract supertype for all astrodynamical parameter vectors. source"},{"id":133,"pagetitle":"Docstrings","title":"AstrodynamicalModels.AstrodynamicalState","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.AstrodynamicalState","content":" AstrodynamicalModels.AstrodynamicalState  —  Type abstract type AstrodynamicalState{F, N} <: StaticArraysCore.FieldVector{N, F} An abstract supertype for all astrodynamical state vectors. source"},{"id":134,"pagetitle":"Docstrings","title":"AstrodynamicalModels.AttitudeParameters","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.AttitudeParameters","content":" AstrodynamicalModels.AttitudeParameters  —  Type struct AttitudeParameters{F} <: AstrodynamicalModels.AstrodynamicalParameters{F, 15} A parameter vector for attitude dynamics. source"},{"id":135,"pagetitle":"Docstrings","title":"AstrodynamicalModels.AttitudeState","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.AttitudeState","content":" AstrodynamicalModels.AttitudeState  —  Type mutable struct AttitudeState{F} <: AstrodynamicalModels.AstrodynamicalState{F, 7} A mutable state vector for attitude dynamics. source"},{"id":136,"pagetitle":"Docstrings","title":"AstrodynamicalModels.CR3BOrbit","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.CR3BOrbit","content":" AstrodynamicalModels.CR3BOrbit  —  Type struct Orbit{var\"#s15\"<:CartesianState, var\"#s14\"<:CR3BParameters} <: AstrodynamicalModels.AstrodynamicalOrbit{var\"#s15\"<:CartesianState, var\"#s14\"<:CR3BParameters} An  Orbit  which exists within CR3BP dynamics. source"},{"id":137,"pagetitle":"Docstrings","title":"AstrodynamicalModels.CR3BParameters","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.CR3BParameters","content":" AstrodynamicalModels.CR3BParameters  —  Type struct CR3BParameters{F} <: AstrodynamicalModels.AstrodynamicalParameters{F, 1} A paremeter vector for CR3BP dynamics. source"},{"id":138,"pagetitle":"Docstrings","title":"AstrodynamicalModels.CartesianSTM","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.CartesianSTM","content":" AstrodynamicalModels.CartesianSTM  —  Type mutable struct CartesianSTM{F} <: StaticArraysCore.FieldMatrix{6, 6, F} A mutable matrix, with labels, for a 6DOF Cartesian state transition matrix. source"},{"id":139,"pagetitle":"Docstrings","title":"AstrodynamicalModels.CartesianState","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.CartesianState","content":" AstrodynamicalModels.CartesianState  —  Type mutable struct CartesianState{F} <: AstrodynamicalModels.AstrodynamicalState{F, 6} A mutable vector, with labels, for 6DOF Cartesian states. source"},{"id":140,"pagetitle":"Docstrings","title":"AstrodynamicalModels.Orbit","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.Orbit","content":" AstrodynamicalModels.Orbit  —  Type struct Orbit{U<:(AbstractVector), P<:(AbstractVector)} <: AstrodynamicalModels.AstrodynamicalOrbit{U<:(AbstractVector), P<:(AbstractVector)} A full representation of an orbit, including a numerical state, and the parameters of the system. source"},{"id":141,"pagetitle":"Docstrings","title":"AstrodynamicalModels.PlanarEntryParameters","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.PlanarEntryParameters","content":" AstrodynamicalModels.PlanarEntryParameters  —  Type struct PlanarEntryParameters{F} <: AstrodynamicalModels.AstrodynamicalParameters{F, 4} A parameter vector for planar entry dynamics. source"},{"id":142,"pagetitle":"Docstrings","title":"AstrodynamicalModels.PlanarEntryState","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.PlanarEntryState","content":" AstrodynamicalModels.PlanarEntryState  —  Type mutable struct PlanarEntryState{F} <: AstrodynamicalModels.AstrodynamicalState{F, 4} A state vector for planar entry dynamics. source"},{"id":143,"pagetitle":"Docstrings","title":"AstrodynamicalModels.R2BOrbit","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.R2BOrbit","content":" AstrodynamicalModels.R2BOrbit  —  Type struct Orbit{var\"#s7\"<:CartesianState, var\"#s6\"<:R2BParameters} <: AstrodynamicalModels.AstrodynamicalOrbit{var\"#s7\"<:CartesianState, var\"#s6\"<:R2BParameters} An  Orbit  which exists within R2BP dynamics. source"},{"id":144,"pagetitle":"Docstrings","title":"AstrodynamicalModels.R2BParameters","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.R2BParameters","content":" AstrodynamicalModels.R2BParameters  —  Type struct R2BParameters{F} <: AstrodynamicalModels.AstrodynamicalParameters{F, 1} A parameter vector for R2BP dynamics. source"},{"id":145,"pagetitle":"Docstrings","title":"AstrodynamicalModels.AttitudeFunction","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.AttitudeFunction-Tuple{}","content":" AstrodynamicalModels.AttitudeFunction  —  Method AttitudeFunction(; stm, name, kwargs...)\n Returns an  ODEFunction  for spacecraft attitude dynamics. Extended Help Usage The  stm  and  name  keyword arguments are passed to  Attitude . All other keyword arguments are passed directly to  SciMLBase.ODEFunction . f = AttitudeFunction()\nlet u = randn(7), p = randn(15), t = NaN # time invariant\n    f(u, p, t)\nend source"},{"id":146,"pagetitle":"Docstrings","title":"AstrodynamicalModels.AttitudeSystem","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.AttitudeSystem-Tuple{}","content":" AstrodynamicalModels.AttitudeSystem  —  Method AttitudeSystem(; stm, name)\n A  ModelingToolkit.ODESystem  for atmospheric entry. Currently, only exponential atmosphere models are provided! The output model is cached with  Memoize.jl . Planet-specific parameters default to Earth values. The order of the states follows:  [q₁, q₂, q₃, q₄, ω₁, ω₂, ω₃] . The order of the parameters follows:  [] Extended Help This model describes how an object moves through an exponential atmosphere, above a spherical planet. States q : scalar-last attitude quaternion ω : body rates (radians per second) Parameters J : inertial matrix L : TODO: what the hell is this? f : torques on the vehicle body (Newton-meters) Usage model = Attitude() source"},{"id":147,"pagetitle":"Docstrings","title":"AstrodynamicalModels.CR3BFunction","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.CR3BFunction-Tuple{}","content":" AstrodynamicalModels.CR3BFunction  —  Method CR3BFunction(; stm, name, kwargs...)\n Returns an  ODEFunction  for CR3B dynamics. The order of the states follows:  [μ] . The order of the parameters follows:  [μ] . Extended Help Usage The  stm , and  name  keyword arguments are passed to  CR3B . All other keyword arguments are passed directly to  SciMLBase.ODEFunction . f = CR3BFunction(; stm=false, jac=true)\nlet u = randn(6), p = randn(1), t = 0\n    f(u, p, t)\nend source"},{"id":148,"pagetitle":"Docstrings","title":"AstrodynamicalModels.CR3BProblem","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.CR3BProblem-Tuple{Any, Any, Any}","content":" AstrodynamicalModels.CR3BProblem  —  Method CR3BProblem(u0, tspan, p; kwargs...)\n Return an  ODEProblem  for the provided CR3B system. source"},{"id":149,"pagetitle":"Docstrings","title":"AstrodynamicalModels.CR3BSystem","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.CR3BSystem-Tuple{}","content":" AstrodynamicalModels.CR3BSystem  —  Method CR3BSystem(; stm, name)\n A  ModelingToolkit.ODESystem  for the Circular Restricted Three-body Problem. The order of the states follows:  [μ] . The order of the parameters follows:  [μ] . Extended Help The Circular Restricted Three-body Problem is a simplified dynamical model describing one small body (spacecraft, etc.) and two celestial bodies moving in a circle about their common center of mass. This may seem like an arbitrary simplification, but this assumption holds reasonably well for the Earth-Moon, Sun-Earth, and many other systems in our solar system. Usage model = CR3BSystem(; stm=true) source"},{"id":150,"pagetitle":"Docstrings","title":"AstrodynamicalModels.NBFunction","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.NBFunction-Tuple{Int64}","content":" AstrodynamicalModels.NBFunction  —  Method NBFunction(N; stm, name, kwargs...)\n Returns an  ODEFunction  for NBP dynamics. The order of states and parameters in the  ODEFunction  arguments are equivalent to the order of states and parameters for the system produced with  NBP(N) . As a general rule, the order of the states follows:  [x₁, y₁, z₁, ..., xₙ, yₙ, zₙ, ẋ₁, ẏ₁, ż₁, ..., ẋₙ, ẏₙ, żₙ] . Note Unlike  R2BP  and  CR3BP ,  jac  is set to  false  by default. The number of states for  NBP  systems can be very large for relatively small numbers of bodies ( N ). Enabling  jac=true  by default would cause unnecessarily long waiting times for this @memoize function to return for  N ≥ 3  or so. If  N=2  and  stm=true , setting  jac=true  could still result in several minutes of calculations, depending on the computer you're using. Warning Be careful about specifying  stm=true  for systems with  N ≥ 3 ! If state transition matrix dynamics are enabled, you can calculate the total number of system states with  N*6 + (N*6)^2 . Note that this increases exponentially as  N  grows! For  N == 6 , unless you're using parallelization, your computer may run for several hours. Extended Help Usage The  stm , and  name  keyword arguments are passed to  NBP . All other keyword arguments are passed directly to  SciMLBase.ODEFunction . f = NBFunction(3; stm=false, name=:NBP, jac=false, sparse=false)\nlet u = randn(3*6), p = randn(1 + 3), t = 0\n    f(u, p, t)\nend source"},{"id":151,"pagetitle":"Docstrings","title":"AstrodynamicalModels.NBSystem","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.NBSystem-Tuple{Int64}","content":" AstrodynamicalModels.NBSystem  —  Method NBSystem(N; stm, name)\n A  ModelingToolkit.ODESystem  for the Newtonian N-body Problem. The order of the states follows:  [x₁, y₁, z₁, ..., xₙ, yₙ, zₙ, ẋ₁, ẏ₁, ż₁, ..., ẋₙ, ẏₙ, żₙ] . The order of the parameters follows:  [G, m₁, m₂, ..., mₙ] . Warning Be careful about specifying  stm=true  for systems with  N ≥ 3 ! If state transition matrix dynamics are enabled, you can calculate the total number of system states with  N*6 + (N*6)^2 . Note that this increases exponentially as  N  grows! For  N == 6 , unless you're using parallelization, your computer may run for several hours. Extended Help The N-body problem is a model which describes how  N  bodies will move with respect to a common origin. This problem typically involves many bodies which act due to one force: electromagentism, gravity, etc. This model applies most closely to many celestial bodies moving due to gravity. That's about right for a model in a package called  AstrodynamicalModels ! Usage # One model for ALL the planets in our solar system 😎\nmodel = NBSystem(9) source"},{"id":152,"pagetitle":"Docstrings","title":"AstrodynamicalModels.PlanarEntryFunction","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.PlanarEntryFunction-Tuple{}","content":" AstrodynamicalModels.PlanarEntryFunction  —  Method PlanarEntryFunction(; name, kwargs...)\n Returns an  ODEFunction  for Planar Entry dynamics. Results are cached with  Memoize.jl . The order of the states follows:  [γ, v, r, θ] . The order of the parameters follows:  [R, P, H, m, A, C, μ] Extended Help Usage The  name  keyword argument is ]passed to  PlanarEntry . All other keyword arguments are passed directly to  SciMLBase.ODEFunction . f = PlanarEntryFunction()\nlet u = randn(4), p = randn(7), t = NaN # time invariant\n    f(u, p, t)\nend source"},{"id":153,"pagetitle":"Docstrings","title":"AstrodynamicalModels.PlanarEntrySystem","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.PlanarEntrySystem-Tuple{}","content":" AstrodynamicalModels.PlanarEntrySystem  —  Method PlanarEntrySystem(; name)\n A  ModelingToolkit.ODESystem  for atmospheric entry. Currently, only exponential atmosphere models are provided! The output model is cached with  Memoize.jl . Planet-specific parameters default to Earth values. The order of the states follows:  [γ, v, r, θ] . The order of the parameters follows:  [R, P, H, m, A, C, μ] Extended Help This model describes how an object moves through an exponential atmosphere, above a spherical planet. Usage model = PlanarEntrySystem() source"},{"id":154,"pagetitle":"Docstrings","title":"AstrodynamicalModels.R2BFunction","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.R2BFunction-Tuple{}","content":" AstrodynamicalModels.R2BFunction  —  Method R2BFunction(; stm, name, kwargs...)\n Returns an  ODEFunction  for R2B dynamics. The order of the states follows:  [x, y, z, ẋ, ẏ, ż] . The order of the parameters follows:  [μ] . Extended Help Usage The  stm , and  name  keyword arguments are passed to  R2B . All other keyword arguments are passed directly to  SciMLBase.ODEFunction . f = R2BFunction(; stm=false, name=:R2B, jac=true)\nlet u = randn(6), p = randn(1), t = 0\n    f(u, p, t)\nend source"},{"id":155,"pagetitle":"Docstrings","title":"AstrodynamicalModels.R2BProblem","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.R2BProblem-Tuple{Any, Any, Any}","content":" AstrodynamicalModels.R2BProblem  —  Method R2BProblem(u0, tspan, p; kwargs...)\n Return an  ODEProblem  for the provided R2B system. source"},{"id":156,"pagetitle":"Docstrings","title":"AstrodynamicalModels.R2BSystem","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.R2BSystem-Tuple{}","content":" AstrodynamicalModels.R2BSystem  —  Method R2BSystem(; stm, name)\n A  ModelingToolkit.ODESystem  for the Restricted Two-body Problem. The order of the states follows:  [x, y, z, ẋ, ẏ, ż] . The order of the parameters follows:  [μ] . Extended Help The Restricted Two-body Problem is a simplified dynamical model describing one small body (spacecraft, etc.) and one celestial body. The gravity of the celestial body exhibits a force on the small body. This model is commonly used as a simplification to descibe our solar systems' planets orbiting our sun, or a spacecraft orbiting Earth. Usage model = R2BSystem() source"},{"id":157,"pagetitle":"Docstrings","title":"AstrodynamicalModels.parameters","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.parameters-Tuple{AstrodynamicalModels.Orbit}","content":" AstrodynamicalModels.parameters  —  Method parameters(orbit)\n Return the parameter vector for an  Orbit . source"},{"id":158,"pagetitle":"Docstrings","title":"AstrodynamicalModels.state","ref":"/docs/lib/AstrodynamicalModels/stable/docstrings/#AstrodynamicalModels.state-Tuple{AstrodynamicalModels.Orbit}","content":" AstrodynamicalModels.state  —  Method state(orbit)\n Return the state vector for an  Orbit . source"},{"id":161,"pagetitle":"Getting Started","title":"AstrodynamicalSolvers.jl","ref":"/docs/lib/AstrodynamicalSolvers/stable/#AstrodynamicalSolvers.jl","content":" AstrodynamicalSolvers.jl Common solvers within orbital mechanics and astrodynamics."},{"id":162,"pagetitle":"Getting Started","title":"Installation","ref":"/docs/lib/AstrodynamicalSolvers/stable/#Installation","content":" Installation pkg> add AstrodynamicalSolvers"},{"id":163,"pagetitle":"Getting Started","title":"Getting Started","ref":"/docs/lib/AstrodynamicalSolvers/stable/#Getting-Started","content":" Getting Started This package currently provides periodic orbit, and manifold computations within  Circular Restricted Three Body Problem dynamics."},{"id":164,"pagetitle":"Getting Started","title":"Periodic Orbits","ref":"/docs/lib/AstrodynamicalSolvers/stable/#Periodic-Orbits","content":" Periodic Orbits This package contains differential correctors, and helpful wrapper functions, for  finding periodic orbits within Circular Restricted Three Body Problem dynamics. using AstrodynamicalSolvers\nusing AstrodynamicalModels\nusing OrdinaryDiffEq\nusing Plots\n\nμ = 0.012150584395829193\n\nplanar = let\n    u, T = halo(μ, 1) # lyapunov (planar) orbit\n    u = [u.x, 0, 0, 0, u.ẏ, 0]\n    problem = ODEProblem(CR3BFunction(), u, (0, T), (μ,))\n    solution = solve(problem, Vern9(), reltol=1e-14, abstol=1e-14)\n    plot(solution, idxs=(:x,:y,:z), title = \"Lyapunov Orbit\", label=:none, size=(1600,900), dpi=400, aspect_ratio=1)\nend\n\nextraplanar = let\n    u, T = halo(μ, 2; amplitude=0.01) # halo (non-planar) orbit\n    u = [u.x, 0, u.z, 0, u.ẏ, 0]\n    problem = ODEProblem(CR3BFunction(), u, (0, T), (μ,))\n    solution = solve(problem, Vern9(), reltol=1e-14, abstol=1e-14)\n    plot(solution, idxs=(:x,:y,:z), title = \"Halo Orbit\", label=:none, size=(1600,900), dpi=400, aspect_ratio=1)\nend\n\nplot(planar, extraplanar, layout=(1,2))"},{"id":165,"pagetitle":"Getting Started","title":"Manifold Computations","ref":"/docs/lib/AstrodynamicalSolvers/stable/#Manifold-Computations","content":" Manifold Computations Manifold computations, provided by  AstrodynamicalCalculations.jl , can perturb  halo orbits onto their unstable or stable manifolds. using AstrodynamicalSolvers\nusing AstrodynamicalCalculations\nusing AstrodynamicalModels\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing Plots\n\nμ = 0.012150584395829193\n\nunstable = let\n    u, T = halo(μ, 1; amplitude=0.005)\n\n    u = [u.x, 0, u.z, 0, u.ẏ, 0]\n    Φ = monodromy(u, μ, T)\n\n    ics = let\n        problem = ODEProblem(CR3BFunction(stm=true), vcat(u, vec(I(6))), (0, T), (μ,))\n        solution = solve(problem, Vern9(), reltol=1e-12, abstol=1e-12, saveat=(T / 10))\n\n        solution.u\n    end\n\n    perturbations = [\n        diverge(ic[1:6], reshape(ic[7:end], 6, 6), Φ; eps=-1e-7)\n        for ic in ics\n    ]\n\n    problem = EnsembleProblem(\n        ODEProblem(CR3BFunction(), u, (0.0, 2T), (μ,)),\n        prob_func=(prob, i, repeat) -> remake(prob; u0=perturbations[i]),\n    )\n\n    solution = solve(problem, Vern9(), trajectories=length(perturbations), reltol=1e-14, abstol=1e-14)\nend\n\nstable = let\n    u, T = halo(μ, 2; amplitude=0.005)\n\n    u = [u.x, 0, u.z, 0, u.ẏ, 0]\n    Φ = monodromy(u, μ, T)\n\n    ics = let\n        problem = ODEProblem(CR3BFunction(stm=true), vcat(u, vec(I(6))), (0, T), (μ,))\n        solution = solve(problem, Vern9(), reltol=1e-12, abstol=1e-12, saveat=(T / 10))\n\n        solution.u\n    end\n\n    perturbations = [\n        converge(ic[1:6], reshape(ic[7:end], 6, 6), Φ; eps=1e-7)\n        for ic in ics\n    ]\n\n    problem = EnsembleProblem(\n        ODEProblem(CR3BFunction(), u, (0.0, -2.1T), (μ,)),\n        prob_func=(prob, i, repeat) -> remake(prob; u0=perturbations[i]),\n    )\n\n    solution = solve(problem, Vern9(), trajectories=length(perturbations), reltol=1e-14, abstol=1e-14)\nend\n\nfigure = plot(;\n    aspect_ratio = 1.0,\n    background = :transparent,\n    grid = true,\n    title = \"Unstable and Stable Invariant Manifolds\",\n    size = (1600,900),\n    dpi = 400,\n)\n\nplot!(figure, unstable, idxs=(:x, :y), aspect_ratio=1, label=:none, palette=:blues)\nplot!(figure, stable, idxs=(:x, :y), aspect_ratio=1, label=:none, palette=:blues)\nscatter!(figure, [1-μ], [0], label=\"Moon\", xlabel=\"X (Earth-Moon Distance)\", ylabel=\"Y (Earth-Moon Distance)\", marker=:x, color=:black, markersize=10,)"},{"id":168,"pagetitle":"CR3BSolvers","title":"Circular Restricted Three Body Solvers","ref":"/docs/lib/AstrodynamicalSolvers/stable/cr3bp/#Circular-Restricted-Three-Body-Solvers","content":" Circular Restricted Three Body Solvers All three-body solvers!"},{"id":169,"pagetitle":"CR3BSolvers","title":"AstrodynamicalSolvers.CR3BSolvers","ref":"/docs/lib/AstrodynamicalSolvers/stable/cr3bp/#AstrodynamicalSolvers.CR3BSolvers","content":" AstrodynamicalSolvers.CR3BSolvers  —  Module Solvers specific to the Circular Restricted Three Body Problem. Extended Help Exports halo lyapunov monodromy Imports AstrodynamicalCalculations AstrodynamicalModels Base Core DocStringExtensions LinearAlgebra ModelingToolkit OrdinaryDiffEq StaticArrays source"},{"id":170,"pagetitle":"CR3BSolvers","title":"AstrodynamicalSolvers.CR3BSolvers.extraplanar_differential","ref":"/docs/lib/AstrodynamicalSolvers/stable/cr3bp/#AstrodynamicalSolvers.CR3BSolvers.extraplanar_differential-Tuple{AbstractVector{T} where T, Any}","content":" AstrodynamicalSolvers.CR3BSolvers.extraplanar_differential  —  Method extraplanar_differential(state, μ)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Given a full state vector for CR3BP dynamics, including vertically concatenated columns of the state transition matrix, return the differential correction term for a periodic orbit. source"},{"id":171,"pagetitle":"CR3BSolvers","title":"AstrodynamicalSolvers.CR3BSolvers.halo","ref":"/docs/lib/AstrodynamicalSolvers/stable/cr3bp/#AstrodynamicalSolvers.CR3BSolvers.halo-NTuple{5, Any}","content":" AstrodynamicalSolvers.CR3BSolvers.halo  —  Method halo(x, z, ẏ, μ, T; reltol, abstol, maxiters)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Iterate on an initial guess for halo orbit conditions. source"},{"id":172,"pagetitle":"CR3BSolvers","title":"AstrodynamicalSolvers.CR3BSolvers.halo","ref":"/docs/lib/AstrodynamicalSolvers/stable/cr3bp/#AstrodynamicalSolvers.CR3BSolvers.halo-Tuple{Any, Int64}","content":" AstrodynamicalSolvers.CR3BSolvers.halo  —  Method halo(μ, lagrange; amplitude, phase, hemisphere, kwargs...)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Given a nondimensional mass parameter  μ , and orbit characteristics, construct  an initial guess using Richardson's analytical solution, and iterate on that guess using a differential corrector.  source"},{"id":173,"pagetitle":"CR3BSolvers","title":"AstrodynamicalSolvers.CR3BSolvers.lyapunov","ref":"/docs/lib/AstrodynamicalSolvers/stable/cr3bp/#AstrodynamicalSolvers.CR3BSolvers.lyapunov-NTuple{4, Any}","content":" AstrodynamicalSolvers.CR3BSolvers.lyapunov  —  Method lyapunov(x, ẏ, μ, T; reltol, abstol, maxiters)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Iterate on an initial guess for Lyapunov orbit conditions. source"},{"id":174,"pagetitle":"CR3BSolvers","title":"AstrodynamicalSolvers.CR3BSolvers.monodromy","ref":"/docs/lib/AstrodynamicalSolvers/stable/cr3bp/#AstrodynamicalSolvers.CR3BSolvers.monodromy-Tuple{AbstractVector{T} where T, Any, Any}","content":" AstrodynamicalSolvers.CR3BSolvers.monodromy  —  Method monodromy(\n    u,\n    μ,\n    T;\n    algorithm,\n    reltol,\n    abstol,\n    save_everystep,\n    kwargs...\n)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Solve for the monodromy matrix of the periodic orbit. source"},{"id":175,"pagetitle":"CR3BSolvers","title":"AstrodynamicalSolvers.CR3BSolvers.planar_differential","ref":"/docs/lib/AstrodynamicalSolvers/stable/cr3bp/#AstrodynamicalSolvers.CR3BSolvers.planar_differential-Tuple{AbstractVector{T} where T, Any}","content":" AstrodynamicalSolvers.CR3BSolvers.planar_differential  —  Method planar_differential(state, μ)\n CR3BP Dynamics This computation is valid for Circular Restricted Three Body Problem dynamics. Given a full state vector for CR3BP dynamics, including vertically concatenated columns of the state transition matrix, return the differential correction term for a planar periodic orbit. source"},{"id":178,"pagetitle":"AstrodynamicalSolvers","title":"Reference","ref":"/docs/lib/AstrodynamicalSolvers/stable/reference/#Reference","content":" Reference All exported names."},{"id":179,"pagetitle":"AstrodynamicalSolvers","title":"AstrodynamicalSolvers.AstrodynamicalSolvers","ref":"/docs/lib/AstrodynamicalSolvers/stable/reference/#AstrodynamicalSolvers.AstrodynamicalSolvers","content":" AstrodynamicalSolvers.AstrodynamicalSolvers  —  Module Provides astrodynamical solvers, including Lyapunov and halo orbit correctors. Extended help License MIT License Copyright (c) 2023 Joseph D Carpinelli Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Exports CR3BSolvers halo lyapunov monodromy Imports AstrodynamicalSolvers.CR3BSolvers Base Core DocStringExtensions Reexport source"}]